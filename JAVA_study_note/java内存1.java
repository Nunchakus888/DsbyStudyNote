//Java的堆与栈的内存分配
//例子还取三角形

class Sjx 
{
	int a;
	int b;
	int c;
	int zhouchang () //a b c变量和此函数同属一个类，故，不需要形参
	{       			//Java中函数也叫方法
		return a+b+c;
	}
	double mianji ()
	{
		double p=(a+b+c)/2.0;
		return Math.sqrt(p * (p-a) * (p-b) * (p-c));
		//Java没有头文件，利用库中方法用 库名.方法
	}
}

class Java内存1  
{
	public static void main (String[] args) 
	{
		Sjx q;//在栈中分配一个空间q，指针类型
		Sjx g = new Sjx();//在栈中定义一个引用（指针）g
						//在堆中分配一个Sjx大小的空间，并转换成Sjx类型
						//让g指向在堆中分配的空间
						//new Sjx()后的不可写成new Sjx ，在C++中支持没括号，Java不支持
		g.a=4;
		g.b=5;
		g.c = 6;
		System.out.printf ("%d,%d,%d\n周长是：%d\n面积是：%f\n" ,g.a,g.b,g.c,g.zhouchang(), g.mianji());
						
		//q.a  = 3;//错误！(提示是：可能没初始化的变量)  在java中自定义类型默认定义是引用类型（也就是指针），所以q只是用来存放地址，不存放数据
				//在没给q指定指向时，q只是一个空引用		
		q = g; //把g指向的空间用q也指向。这样改变q.a或者其他的值。g.a对应的也改变
		q.a = 3; 
		q.b = 4;
		q.c = 5;
		
		System.out.printf ("%d,%d,%d\n周长是：%d\n面积是：%f\n" ,q.a,q.b,q.c,q.zhouchang(), q.mianji());
		System.out.printf ("%d,%d,%d\n周长是：%d\n面积是：%f\n" ,g.a,g.b,g.c,g.zhouchang(), g.mianji());

		// int i = new int();//错误！java不支持在栈中分配基本数据类型
		// int a[5];//错误！Java不支持静态栈中分配数组
		
		int a[] = new int[5];//动态在堆中分配数组，并在栈中分配一引用（指针）指向堆中的内存，
		
		a[0] = 1; a[1]=10;
		System.out.printf ("%d" ,a[1]);
		
		//Java具有垃圾内存回收机制，所以我们在使用时，只需分配我们所需要的内存，系统会子松清楚我们不需要的内存空间
	}
}

/*
	在Java中支持自动回收内存。所以在手动分配和回收内存方面堆和栈差别不是很大。
	Java只支持基本数据类型和引用（指针）在栈中分配内存。类和数组只是栈中分配一个引用（指针）
	数据的储存要在堆中分配，实质和C++中指针一样，但是访问在栈中分配访问方法一样。不像C++中那么明确区分指针和普通栈中
	分配。但是，多个引用（指向）同时引用一块空间的问题和指针一样，要注意。
	
	
	
	
《Java内存分配中的栈》

在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配。
   
 当在一段代码块定义一个变量时，Java就在栈中 为这个变量分配内存空间，当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。

《Java内存分配中的堆》

堆内存用来存放由new创建的对象和数组。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。

在堆中产生了一个数组或对象后，还可以 在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。  引用变量就相当于是 为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量就相当于是为数组或者对象起的一个名称。

引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序 运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍 然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是 Java 比较占内存的原因。

<实际上，栈中的变量指向堆内存中的变量，这就是Java中的指针！>
  
*/